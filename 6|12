Rat in a mace 

public class Main
{
    private boolean dfs(int[][] m, int x, int y, int n) {
        // if destination has reached
        if(x == n -1 && y == n - 1){
            return true;
        }
        
        // if the cell is blocked or already visited
        if (m[x][y] == 0) return false;
        
        // mark the cell as visited
        m[x][y] = 0;
        
        // logic 
        boolean found = false;
        
        // move to the up 
        if( x > 0 ) {
            found = dfs(m, x - 1, y, n);
        }
        // move to the down
        if(!found && x < n - 1 ) {
            found = dfs(m, x + 1, y, n);
        }
        // move to the left
        if(!found && y > 0 ) {
            found = dfs(m, x, y - 1, n);
        }
        // move the right 
        if(!found && y < n - 1) {
            found = dfs(m, x, y + 1, n);
        }
        
        // backtracking 
        // used for making a cell unmarked or unvisited
        m[x][y] = 1;
        
        return found;
    }
    public boolean canReachDestination(int[][] grid) {
        int n = grid.length;
        
        // if starting or ending position is blocked 
        // then i cant reach to the destination
        if(grid[0][0] == 0 || grid[n - 1][ n - 1] == 0){
            return false;
        }
        return dfs(grid, 0, 0, n);
    }
    
	public static void main(String[] args) {
	    Main main = new Main();
	    
		int[][] grid = {
		          {1, 0, 0, 0},
		          {1, 1, 0, 1},
		          {1, 1, 0, 0},
		          {0, 1, 1, 1}
		    };
	System.out.println(main.canReachDestination(grid));	    
	}
}


LC 51 
class Solution {
   public boolean isSafe(int row, int col, char[][] board) {
       // horizontal
       for (int j = 0; j < board.length; j++) {
           if (board[row][j] == 'Q') {
               return false;
           }
       }


       // vertical
       for (int i = 0; i < board.length; i++) {
           if (board[i][col] == 'Q') {
               return false;
           }
       }


       // upper left
       int r = row;
       for (int c = col; c >= 0 && r >= 0; c--, r--) {
           if (board[r][c] == 'Q') {
               return false;
           }
       }


       // upper right
       r = row;
       for (int c = col; c < board.length && r >= 0; r--, c++) {
           if (board[r][c] == 'Q') {
               return false;
           }
       }


       // lower left
       r = row;
       for (int c = col; c >= 0 && r < board.length; r++, c--) {
           if (board[r][c] == 'Q') {
               return false;
           }
       }


       // lower right
       for (int c = col; c < board.length && r < board.length; c++, r++) {
           if (board[r][c] == 'Q') {
               return false;
           }
       }


       return true;
   }


   public void saveBoard(char[][] board, List<List<String>> allBoards) {
       String row = "";
       List<String> newBoard = new ArrayList<>();


       for (int i = 0; i < board.length; i++) {
           row = "";
           for (int j = 0; j < board[0].length; j++) {
               if (board[i][j] == 'Q')
                   row += 'Q';
               else
                   row += '.';
           }
           newBoard.add(row);
       }


       allBoards.add(newBoard);
   }


   public void helper(char[][] board, List<List<String>> allBoards, int col) {
       if (col == board.length) {
           saveBoard(board, allBoards);
           return;
       }


       for (int row = 0; row < board.length; row++) {
           if (isSafe(row, col, board)) {
               board[row][col] = 'Q';
               helper(board, allBoards, col + 1);
               board[row][col] = '.';
           }
       }
   }


   public List<List<String>> solveNQueens(int n) {
       List<List<String>> allBoards = new ArrayList<>();
       char[][] board = new char[n][n];


       helper(board, allBoards, 0);
       return allBoards;
   }
}
